<html>
	<head>
		<title>Mapa Sistema RIO</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" integrity="sha512-h9FcoyWjHcOcmEVkxOfTLnmZFWIH0iZhZT1H2TbOq55xssQGEJHEaIm+PgoUaZbRvQTNTluNOEfb1ZRy6D3BOw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js" integrity="sha512-puJW3E/qXDqYp9IfhAI54BJEaWIfloJ7JWs7OeD5i6ruC9JZL1gERT1wjtwXFlh7CjE7ZJ+/vcRZRkIYIb6p4g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js" integrity="sha512-Q7HOppxoH0L2M7hreVoFCtUZimR2YaY0fBewIYzkCgmNtgOOZ5IgMNYxHgfps0qrO1ef5m7L1FeHrhXlq1I9HA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
			body::-webkit-scrollbar {
				display: none;
			}
			#map {
				width: 100%;
				height: 100%;
			}
			#extension {
				display: none;
			}
			form {
				display: none;
				margin: 0;
			}
			#linhas {
				display: none;
				margin-top: 0.5em;
				font-size: small;
			}
			#linhas div {
				display: block;
				margin-top: 0.25em;
				width: 1px;
				min-width: 100%;
			}
			#linhas a {
				color: #ff0000;
				font-weight: bold;
				text-decoration: none;
			}
			.floating {
				background: none;
				border: none;
				box-shadow: none;
				color: #ffffff;
				text-shadow: 0 0 4px #000000;
			}
			.area {
				font-size: min(48px, 10vmin);
			}
			.lote {
				font-size: min(12px, 10vmin);
			}
			.grayscale {
				filter: grayscale(1);
			}
			.leaflet-popup-content > p {
				margin: 0.75em 0;
			}
			.pulled::before {
				color: #ff0000;
				font-weight: bold;
				content: "Devolvida pelo acordo judicial";
			}
		</style>
		<script>
			var map;
			var polylines = {};
			var areas = {};
			var lotesE = {};
			var lotesL = {};
			const polylineColor = '#0000ff';
			const polylineColorHilit = '#ffff00';
			window.addEventListener('load', () => {
				const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
					'maxZoom': 19,
					'attribution': '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
				});
				map = L.map('map', {
					'layers': [osm]
				});
				const ExtendedLayers = L.Control.Layers.extend({
					'onAdd': function(map) {
						const container = L.Control.Layers.prototype.onAdd.call(this, map);
						const moveFrom = document.querySelector('#extension');
						const moveData = moveFrom.innerHTML;
						moveFrom.innerHTML = '';
						container.querySelector('section').insertAdjacentHTML('beforeend', moveData);
						return container;
					}
				});
				const layerControl = new ExtendedLayers({}, {}, {
					'collapsed': false
				}).addTo(map);

				const geoJsonOverlay = (url, name, obj, label) => new Promise((resolve) => {
					var layers = [];
					loadGeoJson(url, (feature) => {
						var mergedPolyline = [];
						var allPolylines = obj[feature['properties']['name']] = [];
						for (const polyline of getPolylines(feature)) {
							if (label)
								mergedPolyline = mergedPolyline.concat(polyline);
							allPolylines.push(turf.polygon([polyline]));
							layers.push(L.polygon(L.GeoJSON.coordsToLatLngs(polyline), {
								'color': feature['properties']['color'],
								'fillOpacity': 0.5,
								'stroke': true,
								'interactive': false
							}));
						}
						if (label) {
							layers.push(L.tooltip(L.PolyUtil.polygonCenter(L.GeoJSON.coordsToLatLngs(mergedPolyline), L.CRS.EPSG3857), {
								'content': feature['properties']['name'],
								'className': 'floating ' + label,
								'direction': 'center',
								'permanent': true
							}));
						}
					}, (err) => {
						if (!err && layers.length) {
							const group = L.layerGroup(layers)
							group.on('add', () => Object.keys(polylines).forEach((servico) => polylines[servico].forEach((polyline) => polyline.bringToFront())));
							layerControl.addOverlay(group, name);
							resolve(group);
						} else {
							resolve();
						}
					});
				});
				Promise.resolve()
					.then(() => geoJsonOverlay('/mapa-rio/areas.geojson', 'Áreas', areas, 'area'))
					.then((group) => new Promise((resolve) => {
						map.fitBounds([[-22.775, -43.797], [-23.077, -43.149]]);
						group.addTo(map);
						resolve();
					}))
					.then(() => geoJsonOverlay('/mapa-rio/lotes-e.geojson', 'Lotes Estrutrurais', lotesE, 'lote'))
					.then(() => geoJsonOverlay('/mapa-rio/lotes-l.geojson', 'Lotes Locais', lotesL, 'lote'))
					.then(() => new Promise((resolve) => {
						var layers = [];
						loadGeoJson('/mapa-rio/garagens.geojson', (feature) => {
							const polyline = L.GeoJSON.coordsToLatLngs(getPolylines(feature)[0]);
							const marker = L.marker(L.PolyUtil.polygonCenter(polyline, L.CRS.EPSG3857));
							var popup = Object.keys(feature['properties']).filter((key) => key.charAt(0) != '_').map((key) => '<p><b>' + key + ':</b><br />' + feature['properties'][key] + '</p>').join('');
							if (feature['properties']['_pulled']) {
								popup = '<p class="pulled"></p>' + popup;
								marker.on('add', function() {
									this._icon.classList.add('grayscale');
								});
							}
							layers.push(marker.bindPopup(popup));

							marker.polygon = L.polygon(polyline, {
								'color': polylineColor,
								'interactive': false
							});
							marker.on('popupopen', function() {
								this.polygon.addTo(map);
							});
							marker.on('popupclose', function() {
								this.polygon.remove();
							});
						}, (err) => {
							if (!err && layers.length)
								layerControl.addOverlay(L.layerGroup(layers), 'Garagens');

							document.querySelector('#loading').style.display = 'none';
							document.querySelector('form').style.display = 'block';

							resolve();
						});
					}));
			});
			function loadGeoJson(url, feature, finish) {
				window.fetch(url)
					.then((response) => response.json())
					.then((data) => {
						if (data['features'] && data['features'].length)
							data['features'].forEach(feature);
						finish();
					})
					.catch((err) => {
						console.error(err);
						finish(err);
					});
			}
			function getPolylines(feature) {
				if (feature['geometry']['type'] == 'Polygon')
					return feature['geometry']['coordinates'];
				else if (feature['geometry']['type'] == 'MultiPolygon')
					return feature['geometry']['coordinates'].map((x) => x[0]);
				else
					return [];
			}
			function exibir() {
				const inputBox = document.querySelector('#linha');
				const servico = (inputBox.value.toUpperCase().match(/[0-9A-Z]+/) || [])[0];
				inputBox.value = '';
				if (!servico || polylines[servico])
					return false;
				polylines[servico] = [];
				var circular = true;
				var desc;
				loadGeoJson('https://pgeo3.rio.rj.gov.br/arcgis/rest/services/Hosted/Itiner%C3%A1rios_da_rede_de_transporte_p%C3%BAblico_por_%C3%B4nibus_%28SPPO%29/FeatureServer/1/query?where=' + encodeURIComponent('servico=\'' + servico + '\'') + '&outFields=servico%2Cdirecao&outSR=4326&f=pjson', (feature) => {
					const path = feature['geometry']['paths'][0];
					polylines[servico].push(L.polyline(L.GeoJSON.coordsToLatLngs(path), {'color': polylineColor}).bindPopup(servico).addTo(map));

					if (feature['attributes']['direcao']) {
						circular = false;
					} else {
						const startPos = turf.point(path[0]);
						const endPos = turf.point(path[path.length - 1]);
						console.log(endPos);
						var startArea, endArea;
						for (const loteL in lotesL) {
							for (var polyline of lotesL[loteL]) {
								console.log(loteL, lotesL[loteL], polyline);
								if (turf.booleanPointInPolygon(startPos, polyline))
									startArea = loteL;
								if (turf.booleanPointInPolygon(endPos, polyline))
									endArea = loteL;
							}
						}
						if (startArea == endArea) {
							desc = 'Local ' + startArea;
						} else {
							for (const loteE in lotesE) {
								for (var polyline of lotesE[loteE]) {
									if (turf.booleanPointInPolygon(startPos, polyline))
										startArea = loteE;
									if (turf.booleanPointInPolygon(endPos, polyline))
										endArea = loteE;
								}
							}
							desc = 'Estrutural ' + startArea + ' x ' + endArea;
						}
					}
				}, (err) => {
					if (err) {
						alert('Erro ao carregar linha ' + servico);
					} else if (!polylines[servico].length) {
						alert('Linha ' + servico + ' não existe na base de dados do GPS');
					} else {
						if (circular)
							desc = desc.replace(/^Local /, 'Circular ');

						const container = document.querySelector('#linhas');
						container.style.display = 'block';
						container.innerHTML += '<div id="linha-' + servico + '" onmouseover="realce(this, true)" onmouseout="realce(this, false)"><a href="#" onclick="return ocultar(this)">\u274C</a> ' + servico + ' <small>' + desc + '</small></div>';
					}
				});
				return false;
			}
			function ocultar(a) {
				const node = a.parentNode;
				const servico = node.id.slice(6);
				polylines[servico].forEach((polyline) => polyline.remove());
				delete polylines[servico];
				const container = node.parentNode;
				container.removeChild(node);
				if (!container.firstElementChild)
					container.style.display = 'none';
				return false;
			}
			function realce(node, state) {
				const servico = node.id.slice(6);
				if (state) {
					node.style.background = polylineColorHilit;
					polylines[servico].forEach((polyline) => {
						polyline.setStyle({'color': polylineColorHilit});
						polyline.bringToFront();
					});
				} else {
					node.style.background = '';
					polylines[servico].forEach((polyline) => polyline.setStyle({'color': polylineColor}));
				}
			}
		</script>
	</head>
	<body>
		<div id="map"></div>
		<div id="extension">
			<div class="leaflet-control-layers-separator"></div>
			<div class="leaflet-control-layers-overlays">
				<div id="loading">Carregando...</div>
				<form onsubmit="return exibir()">
					<label for="linha">Linha:</label>
					<input type="text" id="linha" size="4" autofocus />
					<button type="submit">Exibir</button>
					<div id="linhas"></div>
				</form>
			</div>
		</div>
	</body>
</html>
